/*!
 * @nuxt/config-edge v2.16.0-27260655.293dc11a (c) 2016-2021
 * Released under the MIT License
 * Repository: https://github.com/nuxt/nuxt.js
 * Website: https://nuxtjs.org
*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const lodash = require('lodash');
const env = require('std-env');
const utilsEdge = require('@nuxt/utils-edge');
const path = require('path');
const fs = require('fs');
const defu = require('defu');
const consola = require('consola');
const destr = require('destr');
const ufo = require('ufo');
const dotenv = require('dotenv');
const rc = require('rc9');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      if (k !== 'default') {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    }
  }
  n["default"] = e;
  return Object.freeze(n);
}

const env__default = /*#__PURE__*/_interopDefaultLegacy(env);
const path__default = /*#__PURE__*/_interopDefaultLegacy(path);
const fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
const defu__default = /*#__PURE__*/_interopDefaultLegacy(defu);
const consola__default = /*#__PURE__*/_interopDefaultLegacy(consola);
const destr__default = /*#__PURE__*/_interopDefaultLegacy(destr);
const dotenv__default = /*#__PURE__*/_interopDefaultLegacy(dotenv);
const rc__namespace = /*#__PURE__*/_interopNamespace(rc);

const _app = () => ({
  vue: {
    config: {
      silent: void 0,
      performance: void 0
    }
  },
  vueMeta: null,
  head: {
    meta: [],
    link: [],
    style: [],
    script: []
  },
  fetch: {
    server: true,
    client: true
  },
  plugins: [],
  extendPlugins: null,
  css: [],
  layouts: {},
  ErrorPage: null,
  loading: {
    color: "black",
    failedColor: "red",
    height: "2px",
    throttle: 200,
    duration: 5e3,
    continuous: false,
    rtl: false,
    css: true
  },
  loadingIndicator: "default",
  pageTransition: {
    name: "page",
    mode: "out-in",
    appear: false,
    appearClass: "appear",
    appearActiveClass: "appear-active",
    appearToClass: "appear-to"
  },
  layoutTransition: {
    name: "layout",
    mode: "out-in"
  },
  features: {
    store: true,
    layouts: true,
    meta: true,
    middleware: true,
    transitions: true,
    deprecations: true,
    validate: true,
    asyncData: true,
    fetch: true,
    clientOnline: true,
    clientPrefetch: true,
    componentAliases: true,
    componentClientOnly: true
  }
});

const _common = () => ({
  dev: Boolean(env__default["default"].dev),
  test: Boolean(env__default["default"].test),
  debug: void 0,
  env: {},
  createRequire: void 0,
  target: utilsEdge.TARGETS.server,
  ssr: true,
  mode: void 0,
  modern: void 0,
  modules: [],
  buildModules: [],
  _modules: [],
  globalName: void 0,
  globals: {
    id: (globalName) => `__${globalName}`,
    nuxt: (globalName) => `$${globalName}`,
    context: (globalName) => `__${globalName.toUpperCase()}__`,
    pluginPrefix: (globalName) => globalName,
    readyCallback: (globalName) => `on${lodash.capitalize(globalName)}Ready`,
    loadedCallback: (globalName) => `_on${lodash.capitalize(globalName)}Loaded`
  },
  serverMiddleware: [],
  _nuxtConfigFile: void 0,
  srcDir: void 0,
  buildDir: ".nuxt",
  modulesDir: [
    "node_modules"
  ],
  dir: {
    assets: "assets",
    app: "app",
    layouts: "layouts",
    middleware: "middleware",
    pages: "pages",
    static: "static",
    store: "store"
  },
  extensions: [],
  styleExtensions: ["css", "pcss", "postcss", "styl", "stylus", "scss", "sass", "less"],
  alias: {},
  ignoreOptions: void 0,
  ignorePrefix: "-",
  ignore: [
    "**/*.test.*",
    "**/*.spec.*"
  ],
  watch: [],
  watchers: {
    rewatchOnRawEvents: void 0,
    webpack: {
      aggregateTimeout: 1e3
    },
    chokidar: {
      ignoreInitial: true
    }
  },
  editor: void 0,
  hooks: null,
  privateRuntimeConfig: {},
  publicRuntimeConfig: {}
});

const build = () => ({
  quiet: Boolean(env__default["default"].ci || env__default["default"].test),
  analyze: false,
  profile: process.argv.includes("--profile"),
  extractCSS: false,
  cssSourceMap: void 0,
  ssr: void 0,
  parallel: false,
  cache: false,
  standalone: false,
  publicPath: "/_nuxt/",
  serverURLPolyfill: "url",
  filenames: {
    app: ({ isDev, isModern }) => isDev ? `[name]${isModern ? ".modern" : ""}.js` : `[contenthash:7]${isModern ? ".modern" : ""}.js`,
    chunk: ({ isDev, isModern }) => isDev ? `[name]${isModern ? ".modern" : ""}.js` : `[contenthash:7]${isModern ? ".modern" : ""}.js`,
    css: ({ isDev }) => isDev ? "[name].css" : "css/[contenthash:7].css",
    img: ({ isDev }) => isDev ? "[path][name].[ext]" : "img/[name].[contenthash:7].[ext]",
    font: ({ isDev }) => isDev ? "[path][name].[ext]" : "fonts/[name].[contenthash:7].[ext]",
    video: ({ isDev }) => isDev ? "[path][name].[ext]" : "videos/[name].[contenthash:7].[ext]"
  },
  loaders: {
    file: { esModule: false },
    fontUrl: { esModule: false, limit: 1e3 },
    imgUrl: { esModule: false, limit: 1e3 },
    pugPlain: {},
    vue: {
      transformAssetUrls: {
        video: "src",
        source: "src",
        object: "src",
        embed: "src"
      }
    },
    css: {
      esModule: false,
      modules: {
        compileType: "icss"
      }
    },
    cssModules: {
      esModule: false,
      modules: {
        localIdentName: "[local]_[hash:base64:5]"
      }
    },
    less: {},
    sass: {
      sassOptions: {
        indentedSyntax: true
      }
    },
    scss: {},
    stylus: {},
    vueStyle: {}
  },
  styleResources: {},
  plugins: [],
  terser: {},
  hardSource: false,
  aggressiveCodeRemoval: false,
  optimizeCSS: void 0,
  optimization: {
    runtimeChunk: "single",
    minimize: void 0,
    minimizer: void 0,
    splitChunks: {
      chunks: "all",
      automaticNameDelimiter: "/",
      cacheGroups: {}
    }
  },
  splitChunks: {
    layouts: false,
    pages: true,
    commons: true
  },
  corejs: "auto",
  babel: {
    configFile: false,
    babelrc: false,
    cacheDirectory: void 0
  },
  transpile: [],
  postcss: {
    preset: {
      stage: 2
    }
  },
  html: {
    minify: {
      collapseBooleanAttributes: true,
      decodeEntities: true,
      minifyCSS: true,
      minifyJS: true,
      processConditionalComments: true,
      removeEmptyAttributes: true,
      removeRedundantAttributes: true,
      trimCustomFragments: true,
      useShortDoctype: true
    }
  },
  template: void 0,
  templates: [],
  watch: [],
  devMiddleware: {
    stats: "none"
  },
  hotMiddleware: {},
  stats: {
    excludeAssets: [
      /.map$/,
      /index\..+\.html$/,
      /vue-ssr-(client|modern)-manifest.json/
    ]
  },
  friendlyErrors: true,
  additionalExtensions: [],
  warningIgnoreFilters: [],
  followSymlinks: false,
  loadingScreen: {},
  indicator: {
    position: "bottom-right",
    backgroundColor: "#2E495E",
    color: "#00C48D"
  }
});

const messages = () => ({
  loading: "Loading...",
  error_404: "This page could not be found",
  server_error: "Server error",
  nuxtjs: "Nuxt",
  back_to_home: "Back to the home page",
  server_error_details: "An error occurred in the application and your page could not be served. If you are the application owner, check your logs for details.",
  client_error: "Error",
  client_error_details: "An error occurred while rendering the page. Check developer tools console for details."
});

const modes = () => ({
  [utilsEdge.MODES.universal]: {
    build: {
      ssr: true
    },
    render: {
      ssr: true
    }
  },
  [utilsEdge.MODES.spa]: {
    build: {
      ssr: false
    },
    render: {
      ssr: false
    }
  }
});

const render = () => ({
  bundleRenderer: {
    shouldPrefetch: () => false,
    shouldPreload: (fileWithoutQuery, asType) => ["script", "style"].includes(asType),
    runInNewContext: void 0
  },
  crossorigin: void 0,
  resourceHints: true,
  ssr: void 0,
  ssrLog: void 0,
  http2: {
    push: false,
    shouldPush: null,
    pushAssets: null
  },
  static: {
    prefix: true
  },
  compressor: {
    threshold: 0
  },
  etag: {
    weak: false
  },
  csp: false,
  dist: {
    index: false,
    maxAge: "1y"
  },
  fallback: {
    dist: {},
    static: {
      skipUnknown: true,
      handlers: {
        ".htm": false,
        ".html": false
      }
    }
  }
});

const router = () => ({
  mode: "history",
  base: "/",
  routes: [],
  routeNameSplitter: "-",
  middleware: [],
  linkActiveClass: "nuxt-link-active",
  linkExactActiveClass: "nuxt-link-exact-active",
  linkPrefetchedClass: false,
  extendRoutes: null,
  scrollBehavior: null,
  parseQuery: false,
  stringifyQuery: false,
  fallback: false,
  prefetchLinks: true,
  prefetchPayloads: true,
  trailingSlash: void 0
});

const server = ({ env = {} } = {}) => ({
  https: false,
  port: env.NUXT_PORT || env.PORT || env.npm_package_config_nuxt_port || 3e3,
  host: env.NUXT_HOST || env.HOST || env.npm_package_config_nuxt_host || "localhost",
  socket: env.UNIX_SOCKET || env.npm_package_config_unix_socket,
  timing: false
});

const cli = () => ({
  badgeMessages: [],
  bannerColor: "green"
});

const generate = () => ({
  dir: "dist",
  routes: [],
  exclude: [],
  concurrency: 500,
  ignoreEnv: false,
  interval: 0,
  subFolders: true,
  fallback: "200.html",
  crawler: true,
  manifest: true,
  nojekyll: true,
  cache: {
    ignore: [],
    globbyOptions: {
      gitignore: true
    }
  },
  staticAssets: {
    base: void 0,
    versionBase: void 0,
    dir: "static",
    version: void 0
  }
});

const defaultNuxtConfigFile = "nuxt.config";
function getDefaultNuxtConfig(options = {}) {
  if (!options.env) {
    options.env = process.env;
  }
  return {
    ..._app(),
    ..._common(),
    build: build(),
    messages: messages(),
    modes: modes(),
    render: render(),
    router: router(),
    server: server(options),
    cli: cli(),
    generate: generate()
  };
}

function getNuxtConfig(_options) {
  if (_options.__normalized__) {
    return _options;
  }
  const options = Object.assign({}, _options);
  options.__normalized__ = true;
  if (options.loading === true) {
    delete options.loading;
  }
  if (options.router && options.router.middleware && !Array.isArray(options.router.middleware)) {
    options.router.middleware = [options.router.middleware];
  }
  if (options.router && typeof options.router.base === "string") {
    options._routerBaseSpecified = true;
  }
  if (options.router && typeof options.router.scrollBehavior !== "undefined") {
    consola__default["default"].warn("`router.scrollBehavior` property is deprecated in favor of using `~/app/router.scrollBehavior.js` file, learn more: https://nuxtjs.org/api/configuration-router#scrollbehavior");
  }
  if (typeof options.transition !== "undefined") {
    consola__default["default"].warn("`transition` property is deprecated in favor of `pageTransition` and will be removed in Nuxt 3");
    options.pageTransition = options.transition;
    delete options.transition;
  }
  if (typeof options.pageTransition === "string") {
    options.pageTransition = { name: options.pageTransition };
  }
  if (typeof options.layoutTransition === "string") {
    options.layoutTransition = { name: options.layoutTransition };
  }
  if (typeof options.extensions === "string") {
    options.extensions = [options.extensions];
  }
  options.globalName = utilsEdge.isNonEmptyString(options.globalName) && /^[a-zA-Z]+$/.test(options.globalName) ? options.globalName.toLowerCase() : `nuxt`;
  options.rootDir = utilsEdge.isNonEmptyString(options.rootDir) ? path__default["default"].resolve(options.rootDir) : process.cwd();
  const nuxtConfig = getDefaultNuxtConfig();
  nuxtConfig.build._publicPath = nuxtConfig.build.publicPath;
  if (options.build && !options.build.publicPath) {
    options.build.publicPath = void 0;
  }
  lodash.defaultsDeep(options, nuxtConfig);
  options.target = options.target || "server";
  if (!Object.values(utilsEdge.TARGETS).includes(options.target)) {
    consola__default["default"].warn(`Unknown target: ${options.target}. Falling back to server`);
    options.target = "server";
  }
  if (options.mode) {
    if (options.mode === utilsEdge.MODES.universal && options.ssr || options.mode === utilsEdge.MODES.spa && !options.ssr) {
      consola__default["default"].warn("`mode` option is deprecated. You can safely remove it from `nuxt.config`");
    } else {
      consola__default["default"].warn("`mode` option is deprecated. Please use `ssr: true` for universal mode or `ssr: false` for spa mode and remove `mode` from `nuxt.config`");
    }
  } else {
    options.mode = utilsEdge.MODES.universal;
  }
  if (options.ssr === false) {
    options.mode = utilsEdge.MODES.spa;
  }
  const modePreset = options.modes[options.mode || utilsEdge.MODES.universal];
  if (!modePreset) {
    consola__default["default"].warn(`Unknown mode: ${options.mode}. Falling back to ${utilsEdge.MODES.universal}`);
  }
  lodash.defaultsDeep(options, modePreset || options.modes[utilsEdge.MODES.universal]);
  options.router.base = ufo.withTrailingSlash(ufo.normalizeURL(options.router.base));
  if (options.export) {
    consola__default["default"].warn("export option is deprecated and will be removed in a future version! Please switch to generate");
    options.generate = defu__default["default"](options.export, options.generate);
  }
  exports.export = options.generate;
  const hasSrcDir = utilsEdge.isNonEmptyString(options.srcDir);
  const hasGenerateDir = utilsEdge.isNonEmptyString(options.generate.dir);
  options.srcDir = hasSrcDir ? path__default["default"].resolve(options.rootDir, options.srcDir) : options.rootDir;
  options.buildDir = path__default["default"].resolve(options.rootDir, options.buildDir);
  const { rootDir, srcDir, dir: { assets: assetsDir, static: staticDir } } = options;
  options.alias = {
    "~~": rootDir,
    "@@": rootDir,
    "~": srcDir,
    "@": srcDir,
    [assetsDir]: path__default["default"].join(srcDir, assetsDir),
    [staticDir]: path__default["default"].join(srcDir, staticDir),
    ...options.alias
  };
  if (!options._nuxtConfigFile) {
    options._nuxtConfigFile = path__default["default"].resolve(options.rootDir, `${defaultNuxtConfigFile}.js`);
  }
  if (!options._nuxtConfigFiles) {
    options._nuxtConfigFiles = [
      options._nuxtConfigFile
    ];
  }
  options.watch.push(...options._nuxtConfigFiles);
  utilsEdge.guardDir(options, "rootDir", "buildDir");
  if (hasGenerateDir) {
    options.generate.dir = path__default["default"].resolve(options.rootDir, options.generate.dir);
    utilsEdge.guardDir(options, "rootDir", "generate.dir");
  }
  if (hasSrcDir) {
    utilsEdge.guardDir(options, "srcDir", "buildDir");
    if (hasGenerateDir) {
      utilsEdge.guardDir(options, "srcDir", "generate.dir");
    }
  }
  options.modulesDir = lodash.uniq(utilsEdge.getMainModule().paths.concat([].concat(options.modulesDir).map((dir) => path__default["default"].resolve(options.rootDir, dir))));
  const mandatoryExtensions = ["js", "mjs"];
  options.extensions = mandatoryExtensions.filter((ext) => !options.extensions.includes(ext)).concat(options.extensions);
  if (options.appTemplatePath === void 0) {
    options.appTemplatePath = path__default["default"].resolve(options.buildDir, "views/app.template.html");
    if (fs__default["default"].existsSync(path__default["default"].join(options.srcDir, "app.html"))) {
      options.appTemplatePath = path__default["default"].join(options.srcDir, "app.html");
    }
  } else {
    options.appTemplatePath = path__default["default"].resolve(options.srcDir, options.appTemplatePath);
  }
  options.build.publicPath = options.build.publicPath.replace(/([^/])$/, "$1/");
  options.build._publicPath = options.build._publicPath.replace(/([^/])$/, "$1/");
  if (options.dev && utilsEdge.isUrl(options.build.publicPath)) {
    options.build.publicPath = options.build._publicPath;
  }
  if (options.store !== false && fs__default["default"].existsSync(path__default["default"].join(options.srcDir, options.dir.store)) && fs__default["default"].readdirSync(path__default["default"].join(options.srcDir, options.dir.store)).find((filename) => filename !== "README.md" && filename[0] !== ".")) {
    options.store = true;
  }
  if (options.loadingIndicator) {
    if (!utilsEdge.isPureObject(options.loadingIndicator)) {
      options.loadingIndicator = { name: options.loadingIndicator };
    }
    options.loadingIndicator = Object.assign({
      name: "default",
      color: options.loading && options.loading.color || "#D3D3D3",
      color2: "#F5F5F5",
      background: options.manifest && options.manifest.theme_color || "white",
      dev: options.dev,
      loading: options.messages.loading
    }, options.loadingIndicator);
  }
  if (options.debug === void 0) {
    options.debug = options.dev;
  }
  if (options.render.etag) {
    const { hash } = options.render.etag;
    if (hash) {
      const isFn = typeof hash === "function";
      if (!isFn) {
        options.render.etag.hash = void 0;
        if (options.dev) {
          consola__default["default"].warn(`render.etag.hash should be a function, received ${typeof hash} instead`);
        }
      }
    }
  }
  if (options.render.csp) {
    options.render.csp = defu__default["default"](options.render.csp, {
      hashAlgorithm: "sha256",
      allowedSources: void 0,
      policies: void 0,
      addMeta: Boolean(options.target === utilsEdge.TARGETS.static),
      unsafeInlineCompatibility: false,
      reportOnly: options.debug
    });
    if (options.render.csp.unsafeInlineCompatiblity) {
      consola__default["default"].warn("Using `unsafeInlineCompatiblity` is deprecated and will be removed in Nuxt 3. Use `unsafeInlineCompatibility` instead.");
      options.render.csp.unsafeInlineCompatibility = options.render.csp.unsafeInlineCompatiblity;
      delete options.render.csp.unsafeInlineCompatiblity;
    }
  }
  if (options.build.cssSourceMap === void 0) {
    options.build.cssSourceMap = options.dev;
  }
  const babelConfig = options.build.babel;
  if (babelConfig.cacheDirectory === void 0) {
    babelConfig.cacheDirectory = options.dev;
  }
  if (Array.isArray(babelConfig.presets)) {
    const warnPreset = (presetName) => {
      const oldPreset = "@nuxtjs/babel-preset-app";
      const newPreset = "@nuxt/babel-preset-app-edge";
      if (presetName.includes(oldPreset)) {
        presetName = presetName.replace(oldPreset, newPreset);
        consola__default["default"].warn("@nuxtjs/babel-preset-app has been deprecated, please use @nuxt/babel-preset-app.");
      }
      return presetName;
    };
    babelConfig.presets = babelConfig.presets.map((preset) => {
      const hasOptions = Array.isArray(preset);
      if (hasOptions) {
        preset[0] = warnPreset(preset[0]);
      } else if (typeof preset === "string") {
        preset = warnPreset(preset);
      }
      return preset;
    });
  }
  const vueConfig = options.vue.config;
  if (vueConfig.silent === void 0) {
    vueConfig.silent = !options.dev;
  }
  if (vueConfig.performance === void 0) {
    vueConfig.performance = options.dev;
  }
  const eligibleEnvVariables = lodash.pick(process.env, Object.keys(process.env).filter((k) => k.startsWith("NUXT_ENV_")));
  Object.assign(options.env, eligibleEnvVariables);
  options.ignore = options.ignore ? [].concat(options.ignore) : [];
  if (typeof options.ignorePrefix === "string") {
    options.ignore.push(`**/${options.ignorePrefix}*.*`);
  }
  if (options.render.gzip) {
    consola__default["default"].warn("render.gzip is deprecated and will be removed in a future version! Please switch to render.compressor");
    options.render.compressor = options.render.gzip;
    delete options.render.gzip;
  }
  if (options.render.ssr === false && options.pageTransition) {
    options.pageTransition.appear = true;
  }
  options.render.ssrLog = options.dev ? options.render.ssrLog === void 0 || options.render.ssrLog : false;
  if (options.generate.fallback === true) {
    options.generate.fallback = "404.html";
  }
  if (options.build.stats === "none" || options.build.quiet === true) {
    options.build.stats = false;
  }
  if (typeof options.build.vendor !== "undefined") {
    delete options.build.vendor;
    consola__default["default"].warn("vendor has been deprecated due to webpack4 optimization");
  }
  if (options.build.extractCSS && options.build.parallel) {
    options.build.parallel = false;
    consola__default["default"].warn("extractCSS cannot work with parallel build due to limited work pool in thread-loader");
  }
  if (typeof options.build.extractCSS.allChunks !== "undefined") {
    consola__default["default"].warn("build.extractCSS.allChunks has no effect from v2.0.0. Please use build.optimization.splitChunks settings instead.");
  }
  if (typeof options.devModules !== "undefined") {
    consola__default["default"].warn("`devModules` has been renamed to `buildModules` and will be removed in Nuxt 3.");
    options.buildModules.push(...options.devModules);
    delete options.devModules;
  }
  if (options.build.optimization.minimize === void 0) {
    options.build.optimization.minimize = !options.dev;
  }
  if (options.build.optimizeCSS === void 0) {
    options.build.optimizeCSS = options.build.extractCSS ? {} : false;
  }
  const { loaders } = options.build;
  const vueLoader = loaders.vue;
  if (vueLoader.productionMode === void 0) {
    vueLoader.productionMode = !options.dev;
  }
  const styleLoaders = [
    "css",
    "cssModules",
    "less",
    "sass",
    "scss",
    "stylus",
    "vueStyle"
  ];
  for (const name of styleLoaders) {
    const loader = loaders[name];
    if (loader && loader.sourceMap === void 0) {
      loader.sourceMap = Boolean(options.build.cssSourceMap);
    }
  }
  options.build.transpile = [].concat(options.build.transpile || []);
  if (options.build.quiet === true) {
    consola__default["default"].level = 0;
  }
  const { bundleRenderer } = options.render;
  if (typeof bundleRenderer.runInNewContext === "undefined") {
    bundleRenderer.runInNewContext = options.dev;
  }
  if (options.build.crossorigin) {
    consola__default["default"].warn("Using `build.crossorigin` is deprecated and will be removed in Nuxt 3. Please use `render.crossorigin` instead.");
    options.render.crossorigin = options.build.crossorigin;
    delete options.build.crossorigin;
  }
  const { timing } = options.server;
  if (timing) {
    options.server.timing = { total: true, ...timing };
  }
  if (utilsEdge.isPureObject(options.serverMiddleware)) {
    options.serverMiddleware = Object.entries(options.serverMiddleware).map(([path2, handler]) => ({ path: path2, handler }));
  }
  const useCDN = utilsEdge.isUrl(options.build.publicPath) && !options.dev;
  const isRelativePublicPath = ufo.isRelative(options.build.publicPath);
  options.app = defu__default["default"](options.app, {
    basePath: options.router.base,
    assetsPath: isRelativePublicPath ? options.build.publicPath : useCDN ? "/" : ufo.joinURL(options.router.base, options.build.publicPath),
    cdnURL: useCDN ? options.build.publicPath : null
  });
  options.publicRuntimeConfig = options.publicRuntimeConfig || {};
  options.publicRuntimeConfig._app = options.app;
  const { staticAssets } = options.generate;
  if (!staticAssets.version) {
    staticAssets.version = String(Math.round(Date.now() / 1e3));
  }
  if (!staticAssets.base) {
    staticAssets.base = ufo.joinURL(options.app.assetsPath, staticAssets.dir);
  }
  if (!staticAssets.versionBase) {
    staticAssets.versionBase = ufo.joinURL(staticAssets.base, staticAssets.version);
  }
  const isJest = typeof jest !== "undefined";
  const defaultCreateRequire = isJest ? "native" : "jiti";
  options.createRequire = process.env.NUXT_CREATE_REQUIRE || options.createRequire || defaultCreateRequire;
  if (options.createRequire === "native" || options.createRequire === "jiti") {
    const useJiti = options.createRequire === "jiti";
    options.createRequire = (p) => utilsEdge.createRequire(typeof p === "string" ? p : p.filename, useJiti);
  } else if (typeof options.createRequire !== "function") {
    throw new TypeError(`Unsupported createRequire value ${options.createRequire}! Possible values: "native", "jiti", <Function>`);
  }
  if (options.build.indicator === true) {
    options.build.indicator = nuxtConfig.build.indicator;
  }
  if (!options.dev || !options._cli || !utilsEdge.getPKG("@nuxt/loading-screen")) {
    options.build.loadingScreen = false;
  }
  if (options.build.loadingScreen) {
    options._modules.push(["@nuxt/loading-screen", options.build.loadingScreen]);
  } else {
    options.build.indicator = false;
  }
  if (!options._start && utilsEdge.getPKG("@nuxt/components")) {
    options._modules.push("@nuxt/components");
  }
  if (options.telemetry !== false && !options.test && !destr__default["default"](process.env.NUXT_TELEMETRY_DISABLED) && utilsEdge.getPKG("@nuxt/telemetry")) {
    options._modules.push("@nuxt/telemetry");
  }
  return options;
}

async function loadNuxtConfig({
  rootDir = ".",
  envConfig = {},
  configFile = defaultNuxtConfigFile,
  configContext = {},
  configOverrides = {}
} = {}) {
  var _a, _b, _c, _d, _e;
  rootDir = path__default["default"].resolve(rootDir);
  const _require = utilsEdge.createRequire(rootDir, true);
  let options = {};
  try {
    configFile = _require.resolve(path__default["default"].resolve(rootDir, configFile));
  } catch (e) {
    if (e.code !== "MODULE_NOT_FOUND") {
      throw e;
    } else if (configFile !== defaultNuxtConfigFile) {
      consola__default["default"].fatal("Config file not found: " + configFile);
    }
    configFile = void 0;
  }
  envConfig = {
    dotenv: ".env",
    env: process.env,
    expand: true,
    ...envConfig
  };
  const env = loadEnv(envConfig, rootDir);
  for (const key in env) {
    if (!key.startsWith("_") && envConfig.env[key] === void 0) {
      envConfig.env[key] = env[key];
    }
  }
  if (configFile) {
    utilsEdge.clearRequireCache(configFile);
    options = _require(configFile) || {};
    if (options.default) {
      options = options.default;
    }
    if (typeof options === "function") {
      try {
        options = await options(configContext);
        if (options.default) {
          options = options.default;
        }
      } catch (error) {
        consola__default["default"].error(error);
        consola__default["default"].fatal("Error while fetching async configuration");
      }
    }
    options = { ...options };
    options._nuxtConfigFile = configFile;
    options._nuxtConfigFiles = Array.from(utilsEdge.scanRequireTree(configFile));
    if (!options._nuxtConfigFiles.includes(configFile)) {
      options._nuxtConfigFiles.unshift(configFile);
    }
  }
  if (typeof options.rootDir !== "string") {
    options.rootDir = rootDir;
  }
  const dev = (_b = (_a = configOverrides.dev) != null ? _a : options.dev) != null ? _b : configContext.dev;
  const buildDir = (_e = (_d = (_c = configOverrides.buildDir) != null ? _c : options.buildDir) != null ? _d : configContext.buildDir) != null ? _e : ".nuxt";
  options = defu__default["default"](configOverrides, options, !dev ? rc__namespace.read({ name: "nuxtrc", dir: path__default["default"].resolve(buildDir, "dist") }) : {}, rc__namespace.read({ name: ".nuxtrc", dir: options.rootDir }), rc__namespace.readUser(".nuxtrc"));
  options._env = env;
  options._envConfig = envConfig;
  if (configContext) {
    configContext.env = env;
  }
  if (envConfig.expand) {
    for (const c of ["publicRuntimeConfig", "privateRuntimeConfig"]) {
      if (options[c]) {
        if (typeof options[c] === "function") {
          options[c] = options[c](env);
        }
        expand(options[c], env, destr__default["default"]);
      }
    }
  }
  return options;
}
function loadEnv(envConfig, rootDir = process.cwd()) {
  const env = Object.create(null);
  if (envConfig.dotenv) {
    envConfig.dotenv = path__default["default"].resolve(rootDir, envConfig.dotenv);
    if (fs__default["default"].existsSync(envConfig.dotenv)) {
      const parsed = dotenv__default["default"].parse(fs__default["default"].readFileSync(envConfig.dotenv, "utf-8"));
      Object.assign(env, parsed);
    }
  }
  if (!envConfig.env._applied) {
    Object.assign(env, envConfig.env);
    envConfig.env._applied = true;
  }
  if (envConfig.expand) {
    expand(env);
  }
  return env;
}
function expand(target, source = {}, parse = (v) => v) {
  function getValue(key) {
    return source[key] !== void 0 ? source[key] : target[key];
  }
  function interpolate(value, parents = []) {
    if (typeof value !== "string") {
      return value;
    }
    const matches = value.match(/(.?\${?(?:[a-zA-Z0-9_:]+)?}?)/g) || [];
    return parse(matches.reduce((newValue, match) => {
      const parts = /(.?)\${?([a-zA-Z0-9_:]+)?}?/g.exec(match);
      const prefix = parts[1];
      let value2, replacePart;
      if (prefix === "\\") {
        replacePart = parts[0];
        value2 = replacePart.replace("\\$", "$");
      } else {
        const key = parts[2];
        replacePart = parts[0].substring(prefix.length);
        if (parents.includes(key)) {
          consola__default["default"].warn(`Please avoid recursive environment variables ( loop: ${parents.join(" > ")} > ${key} )`);
          return "";
        }
        value2 = getValue(key);
        value2 = interpolate(value2, [...parents, key]);
      }
      return value2 !== void 0 ? newValue.replace(replacePart, value2) : newValue;
    }, value));
  }
  for (const key in target) {
    target[key] = interpolate(getValue(key));
  }
}

exports.defaultNuxtConfigFile = defaultNuxtConfigFile;
exports.getDefaultNuxtConfig = getDefaultNuxtConfig;
exports.getNuxtConfig = getNuxtConfig;
exports.loadNuxtConfig = loadNuxtConfig;
